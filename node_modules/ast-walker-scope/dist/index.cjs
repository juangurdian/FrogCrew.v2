"use strict";
//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
		key = keys[i];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
const ast_kit = __toESM(require("ast-kit"));
const __babel_parser = __toESM(require("@babel/parser"));

//#region src/utils/babel.ts
const NEW_SCOPE = [
	"CatchClause",
	"ForInStatement",
	"ForOfStatement"
];
const isNewScope = (node) => node && NEW_SCOPE.includes(node.type) || (0, ast_kit.isFunctionType)(node);
function walkFunctionParams(node, onIdent) {
	for (const p of node.params) for (const id of extractIdentifiers(p)) onIdent(id);
}
function extractIdentifiers(param, nodes = []) {
	switch (param.type) {
		case "Identifier":
			nodes.push(param);
			break;
		case "MemberExpression": {
			let object = param;
			while (object.type === "MemberExpression") object = object.object;
			nodes.push(object);
			break;
		}
		case "ObjectPattern":
			for (const prop of param.properties) if (prop.type === "RestElement") extractIdentifiers(prop.argument, nodes);
			else extractIdentifiers(prop.value, nodes);
			break;
		case "ArrayPattern":
			param.elements.forEach((element) => {
				if (element) extractIdentifiers(element, nodes);
			});
			break;
		case "RestElement":
			extractIdentifiers(param.argument, nodes);
			break;
		case "AssignmentPattern":
			extractIdentifiers(param.left, nodes);
			break;
	}
	return nodes;
}
function babelParse(code, filename, parserPlugins = []) {
	const plugins = parserPlugins || [];
	if (filename) {
		if (/\.tsx?$/.test(filename)) plugins.push("typescript");
		if (filename.endsWith("x")) plugins.push("jsx");
	}
	const ast = (0, __babel_parser.parse)(code, {
		sourceType: "module",
		plugins
	});
	return ast;
}
function walkVariableDeclaration(stmt, register) {
	if (stmt.declare) return;
	for (const decl of stmt.declarations) for (const id of extractIdentifiers(decl.id)) register(id);
}
function walkNewIdentifier(node, register) {
	if (node.type === "ExportNamedDeclaration" && node.declaration) node = node.declaration;
	if (node.type === "VariableDeclaration") walkVariableDeclaration(node, register);
	else if (node.type === "FunctionDeclaration" || node.type === "ClassDeclaration") {
		if (node.declare || !node.id) return;
		register(node.id);
	} else if (node.type === "ExportNamedDeclaration" && node.declaration && node.declaration.type === "VariableDeclaration") walkVariableDeclaration(node.declaration, register);
}

//#endregion
//#region src/index.ts
function walk(code, walkHooks, { filename, parserPlugins } = {}) {
	const ast = babelParse(code, filename, parserPlugins);
	walkAST(ast.program, walkHooks);
	return ast;
}
function walkAST(node, { enter, leave, enterAfter, leaveAfter }) {
	let currentScope = {};
	const scopeStack = [currentScope];
	const ast = Array.isArray(node) ? {
		type: "Program",
		body: node
	} : node;
	(0, ast_kit.walkAST)(ast, {
		enter(node$1, parent, ...args) {
			const { scopeCtx, walkerCtx, isSkip, isRemoved, getNode } = getHookContext(this, node$1, [parent, ...args]);
			enter?.call({
				...scopeCtx(),
				...walkerCtx
			}, node$1);
			node$1 = getNode();
			if (!isSkip() && !isRemoved()) {
				enterNode(node$1, parent);
				enterAfter?.call(scopeCtx(), node$1);
			}
		},
		leave(node$1, parent, ...args) {
			const { scopeCtx, walkerCtx, isSkip, isRemoved, getNode } = getHookContext(this, node$1, [parent, ...args]);
			leave?.call({
				...scopeCtx(),
				...walkerCtx
			}, node$1);
			node$1 = getNode();
			if (!isSkip() && !isRemoved()) {
				leaveNode(node$1, parent);
				leaveAfter?.call(scopeCtx(), node$1);
			}
		}
	});
	function getHookContext(ctx, node$1, [parent, key, index]) {
		const scopeCtx = () => ({
			parent,
			key,
			index,
			scope: scopeStack.reduce((prev, curr) => ({
				...prev,
				...curr
			}), {}),
			scopes: scopeStack,
			level: scopeStack.length
		});
		let isSkip = false;
		let isRemoved = false;
		let newNode = node$1;
		const walkerCtx = {
			skip() {
				isSkip = true;
				ctx.skip();
			},
			replace(node$2) {
				newNode = node$2;
			},
			remove() {
				isRemoved = true;
			}
		};
		return {
			scopeCtx,
			walkerCtx,
			isSkip: () => isSkip,
			isRemoved: () => isRemoved,
			getNode: () => newNode
		};
	}
	function enterNode(node$1, parent) {
		if (isNewScope(node$1) || node$1.type === "BlockStatement" && !isNewScope(parent)) scopeStack.push(currentScope = {});
		if ((0, ast_kit.isFunctionType)(node$1)) walkFunctionParams(node$1, registerBinding);
		else if (node$1.type === "CatchClause" && node$1.param && node$1.param.type === "Identifier") registerBinding(node$1.param);
		if (node$1.type === "BlockStatement" || node$1.type === "Program") {
			for (const stmt of node$1.body) if (stmt.type === "VariableDeclaration" && stmt.kind === "var") walkVariableDeclaration(stmt, registerBinding);
			else if (stmt.type === "FunctionDeclaration" && stmt.id) registerBinding(stmt.id);
		}
	}
	function leaveNode(node$1, parent) {
		if (isNewScope(node$1) || node$1.type === "BlockStatement" && !isNewScope(parent)) {
			scopeStack.pop();
			currentScope = scopeStack.at(-1);
		}
		walkNewIdentifier(node$1, registerBinding);
	}
	function registerBinding(id) {
		if (currentScope) currentScope[id.name] = id;
		else error("registerBinding called without active scope, something is wrong.", id);
	}
	function error(msg, node$1) {
		const e = new Error(msg);
		e.node = node$1;
		throw e;
	}
}
function getRootScope(nodes) {
	const scope = {};
	for (const node of nodes) walkNewIdentifier(node, (id) => {
		scope[id.name] = id;
	});
	return scope;
}

//#endregion
exports.babelParse = babelParse
exports.extractIdentifiers = extractIdentifiers
exports.getRootScope = getRootScope
exports.isNewScope = isNewScope
exports.walk = walk
exports.walkAST = walkAST
exports.walkFunctionParams = walkFunctionParams
exports.walkNewIdentifier = walkNewIdentifier
exports.walkVariableDeclaration = walkVariableDeclaration